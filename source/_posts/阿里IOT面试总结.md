## 贝壳面试

- react  钩子函数、生命周期、组件传值。
- vue 双向绑定（v-model）：Object.defineProperty() 定义属性的 setter 和 getter ，监听到变化，发布给订阅者，总结来说就是数据劫持结合发布订阅模式。

## 自我介绍

- 面试官您好，我叫戴鹏。今年25岁，就读于西安电子科技大学的软件工程专业，在明年6月份毕业。
- 在校期间，我在导师实验室层担任过两个项目的管理负责人。在前期跟产品的角色有点类似，主要工作是和甲方进行需求沟通，管理汇报项目进度，在项目的后期自己逐渐涉及一小部分的前端开发。
- 加入贝壳是在今年的六月份，正式开启了我前端开发的职业生涯。

## 实习这段时间做的事情

- 品质租赁项目，toB 给经纪人用的pc端系统，主要功能是录入房源，查看房源，房源状态管理，创建编辑合同，写跟进等功能。管理房源，管理合同管理客源。
- 加盟商管理项目，管理加盟商的信息，主要功能就是信息的增删改查。也是 toB。

可以分为三个阶段，第一个阶段是作为新人对项目技术栈的学习，后面两个阶段分别加入了不同项目的开发。
1. 实习入职的前十天完成了react、dva、antd、antd-pro的初步了解和学习以及完成了第一个模拟需求
天天成交的房源列表以及房源详情。
2. 紧接着一个月的时间加入了品质租赁项目，着手开发房源详情页，根据不同的房源状态展示不同的信息。详情页内部包含一些交互，比如说点击某个按钮进行弹窗，自己动手封装了第一个 react 组件：轮播图。
3. 加盟商管理系统的门店表单页及基础信息详情展示。

## 难点

1. 房源详情页：悬浮窗口实现

（内容包裹区域第二列，滚动一定距离时需要将其固定显示在浏览器顶部，一开始就想到 sticky 这个属性，但是由于兼容性不友好，在项目中肯定不能使用，后来用的是 fixed 相对于浏览器定位，但是设置了 fixed 后，这个元素就脱离了文档流，并且不参与父元素宽度计算，这样一来我的样式就出现了问题。后来的解决的方案是：设置主题内容区域的 padding-right，一开始就为这个悬浮窗口预留好空间，然后悬浮窗口的初始 position 值就设置为 absolute 并且计算好它的相对位置，然后监听滚动事件，当滚动到一定距离的时候再改变它的 position 值为 fixed。 ）

2. 轮播图交互 （通过设置不同的 left 值来控制切换图片， 两个state值 current、currentLeft）

3. 在写表单页的时候，因为字段比较多，所以想用配置文件的形式去写每一项，但是随着需求的迭代，各种表单联动，不同状态下是否可编辑都不一样，导致配置文件越写越大， 变得不直观，违背了一开始的想法。

## 学到了什么

从大点角度来说：
1. 经历项目从 0 到 1 的完整流程，从 PM 提出需求，需求评测，拿到UI稿，经历了联调，提测，包括后面的需求迭代，以及上线。
2. 之前写的代码不够规范，进行了一次 codereview 后 ,知道了要按照代码规范来编写出可维护的代码。养成良好的编码习惯。
3. 接触了新的语言，学习了新的语法以及版本管理工具 Git 的使用

从细节方面来说：

1. 代码中很多之前不清楚的点，经过开发就都有了更深的理解，这是一个积累的过程。（比如说在实现轮播图组件过程中我用到了
this.setState() 这个方法，我原本以为在同一个代码块中，set 完的第二行就可以拿到它的最新状态值，后来才知道 setState 是批量处理的，写一个回调函数传入第二个参数才可以实现拿到最新的状态值。）
2. import 进来的变量是只读的。
3. 拿到后端数据去渲染的时候，很多字段可能都没有，读到它的时候就是 undefined, 如果再对相应的字段去做另外的操作，如果是undefined 就会报错，所以拿到后端数据如果想进一步处理就需要加一些判断。写第一个需求的时候mock 数据的时候没问题，一联调就出现各种问题。

## reskull

1. 基于 webpack 的前端构建工具，初始化了一些配置项，提高开发效率，帮助我们进行打包。

## bucky

基于 koa 的 node 中间层，主要做的事情是请求转发，请求中间处理。

## 你觉得自身有哪些不足

1. 自制力不够，会有计划好的事情没有完成的情况，会因为太累 想着就放到明天再做吧，但一般第二天一定会做完。
3. 有的时候没有关注优先级，导致重要的事情没有先做完。
4. 对同一个缺乏多角度的思考

## 优势

1. 责任心强，能顶得住压力。上进心。
2. 对现在的工作有兴趣，保持热情。
3. 乐观，有自己的兴趣爱好，热爱生活
4. 能够站在他人角度思考问题。

## 性能优化 

1. 使用 cdn
2. 利用浏览器缓存
3. 请求合并，减少网络请求
4. 图片懒加载
5. 减少 DOM 查询；对 DOM 查询作缓存
6. 减少 DOM 操作；var frag = document.createDocumentFragment()
7. 事件节流
## 介绍项目以及自己的所做的工作

## 技术选型原因

1. 公司前端大部分的 pc 端都是用 react 去实现的，所以第一个原因是和其他项目技术栈保持统一，这样便于管理和维护。
2. react 性能很好，不用像jquery时代对dom节点进行操作，转化为对数据的操作，状态更新则重新渲染
3. react 把每个组件当作一个状态机，状态变化会触发重新render。
4. react 虚拟 DOM 和 diff 算法是提高 react 性能的关键。
5. react diff 会帮我们计算出虚拟 DOM 中真正变化的部分，并且只针对变化的部分进行dom操作，而不是重新渲染整个页面，这是性能提升的关键。
6. 对于虚拟 dom diff 算法的理解可以分为四个步骤：1 生成虚拟dom 2. 通过虚拟dom构建真实dom（appendChild） 3. 生成新的虚拟dom 4. 比较两颗虚拟dom 的不同  5. 只对变更的 dom 进行操作 

## react redux 工作机制、原理

### react 工作原理 

两大特色： 状态化管理和组件化开发 、虚拟 DOM 速度很快

工作原理：当内部的状态值发生变化时会自动

特有语法： jsx 语法：可以把 html 语法直接写在 js 中。可以将 html 和 js 写在一起。常用的是在 html 中插入 js 变量，如果变量是一个数组，则会展开所有的成员。

生命周期三个状态：
生命周期函数运行顺序：

同级组件之间的通信方式：除了通过父组件和 store 还有哪种方法可以实现

### redux 工作原理

- react 引入 redux 主要为了解决 组件传值的问题。
- redux 把应用看成一个状态机，视图和状态是一一对应的，当状态变化的时候，会自动触发监听函数
- redux 把所有的状态放在 store 这个对象里
- 它的工作机制可以举一个栗子，当用户点击了某个按钮，触发 dispatch 了一个 action，这个 action 被 store 接收到，调用内部的 reducer，reducer 接受之前的状态值和action，返回一个新的状态值，然后一旦状态改变了，由 store.subscribe() 设置的监听函数就会自动执行。在react里面通常是 render ，于是页面就更新了
- 开发复杂的大型采用 redux 是非常合适的，redux 单向数据流

- [redux 工作原理](https://segmentfault.com/a/1190000004236064)

### dva 框架

## cookie session localstorage sessionStorage

1. 4kb
2. 5M
3. localStorage 永久存储
4. sessionStorage 关闭浏览器就删除