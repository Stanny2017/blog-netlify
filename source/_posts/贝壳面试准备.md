## 贝壳面试

- react  钩子函数、生命周期、组件传值。
- vue 双向绑定（v-model）：Object.defineProperty() 定义属性的 setter 和 getter ，监听到变化，发布给订阅者，总结来说就是数据劫持结合发布订阅模式。

## 自我介绍

- 面试官您好，我叫戴鹏。今年25岁，就读于西安电子科技大学的软件工程专业，在明年6月份毕业。
- 在校期间，我在导师实验室层担任过两个项目的管理负责人。在前期跟产品的角色有点类似，主要工作是和甲方进行需求沟通，管理汇报项目进度，在项目的后期自己逐渐涉及一小部分的前端开发。
- 加入贝壳是在今年的六月份，正式开启了我前端开发的职业生涯。

## 实习这段时间做的事情

- 品质租赁项目，toB 给经纪人用的pc端系统，主要功能是录入房源，查看房源，房源状态管理，创建编辑合同，写跟进等功能。管理房源，管理合同管理客源。
- 加盟商管理项目，管理加盟商的信息，主要功能就是信息的增删改查。也是 toB。

可以分为三个阶段，第一个阶段是作为新人对项目技术栈的学习，后面两个阶段分别加入了不同项目的开发。
1. 实习入职的前十天完成了react、dva、antd、antd-pro的初步了解和学习以及完成了第一个模拟需求
天天成交的房源列表以及房源详情。
2. 紧接着一个月的时间加入了品质租赁项目，着手开发房源详情页，根据不同的房源状态展示不同的信息。详情页内部包含一些交互，比如说点击某个按钮进行弹窗，自己动手封装了第一个 react 组件：轮播图。
3. 加盟商管理系统的门店表单页及基础信息详情展示。

## 难点

1. 房源详情页：悬浮窗口实现

（内容包裹区域第二列，滚动一定距离时需要将其固定显示在浏览器顶部，一开始就想到 sticky 这个属性，但是由于兼容性不友好，在项目中肯定不能使用，后来用的是 fixed 相对于浏览器定位，但是设置了 fixed 后，这个元素就脱离了文档流，并且不参与父元素宽度计算，这样一来我的样式就出现了问题。后来的解决的方案是：设置主题内容区域的 padding-right，一开始就为这个悬浮窗口预留好空间，然后悬浮窗口的初始 position 值就设置为 absolute 并且计算好它的相对位置，然后监听滚动事件，当滚动到一定距离的时候再改变它的 position 值为 fixed。 ）

2. 轮播图交互 （通过设置不同的 left 值来控制切换图片， 两个state值 current、currentLeft）

3. 在写表单页的时候，因为字段比较多，所以想用配置文件的形式去写每一项，但是随着需求的迭代，各种表单联动，不同状态下是否可编辑都不一样，导致配置文件越写越大， 变得不直观，违背了一开始的想法。

## 学到了什么

从大点角度来说：
1. 经历项目从 0 到 1 的完整流程，从 PM 提出需求，需求评测，拿到UI稿，经历了联调，提测，包括后面的需求迭代，以及上线。
2. 之前写的代码不够规范，进行了一次 codereview 后 ,知道了要按照代码规范来编写出可维护的代码。养成良好的编码习惯。
3. 接触了新的语言，学习了新的语法以及版本管理工具 Git 的使用

从细节方面来说：

1. 代码中很多之前不清楚的点，经过开发就都有了更深的理解，这是一个积累的过程。（比如说在实现轮播图组件过程中我用到了
this.setState() 这个方法，我原本以为在同一个代码块中，set 完的第二行就可以拿到它的最新状态值，后来才知道 setState 是批量处理的，写一个回调函数传入第二个参数才可以实现拿到最新的状态值。）
2. import 进来的变量是只读的。
3. 拿到后端数据去渲染的时候，很多字段可能都没有，读到它的时候就是 undefined, 如果再对相应的字段去做另外的操作，如果是undefined 就会报错，所以拿到后端数据如果想进一步处理就需要加一些判断。写第一个需求的时候mock 数据的时候没问题，一联调就出现各种问题。

## reskull

1. 基于 webpack 的前端构建工具，初始化了一些配置项，提高开发效率，帮助我们进行打包。

## bucky

基于 koa 的 node 中间层，主要做的事情是请求转发，请求中间处理。

## 你觉得自身有哪些不足

1. 自制力不够，会有计划好的事情没有完成的情况，会因为太累 想着就放到明天再做吧，但一般第二天一定会做完。
3. 有的时候没有关注优先级，导致重要的事情没有先做完。
4. 对同一个缺乏多角度的思考

## 优势

1. 责任心强，能顶得住压力。上进心。
2. 对现在的工作有兴趣，保持热情。
3. 乐观，有自己的兴趣爱好，热爱生活
4. 能够站在他人角度思考问题。

## 性能优化 

1. 使用 cdn
2. 利用浏览器缓存
3. 请求合并，减少网络请求
4. 图片懒加载
5. 减少 DOM 查询；对 DOM 查询作缓存
6. 减少 DOM 操作；var frag = document.createDocumentFragment()
7. 事件节流